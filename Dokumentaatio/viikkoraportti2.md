# Viikkoraportti #2

Tällä viikolla aloitin sovelluksen varsinaisen kehittämisen luomalla yksinkertaisen graafisen käyttöliittymän JavaFX:n avulla ja toteuttamalla yksinkertaisimmat järjestämisalgoritmit: lisäys- ja kuplajärjestämisen. Sovelluksella pystyy nyt periaatteessa vertailemaan em. algoritmien suorituskykyä, mutta ajan mittaamiseen liittyvissä toteutuksissa on parantamisen varaa. Otin myös Checkstylen käyttöön, mutta käytän vielä toistaiseksi eri tyylitarkistusmäärittelyjä kuin kurssin esimerkkiprojektissa. Tein yksikkötestit molemmille järjestämisalgoritmeille, mutta kaikkia metodeja en vielä testannut, sillä aion seuraavaksi muuttaa järjestämisalgoritmien luokkarakennetta toisteisen koodin vähentämiseksi, jolloin myös testattavien metodien määrä vähenee. Käyttöliittymäkoodin jätän tyylitarkistusten ja testikattavuusraportin ulkopuolelle. Kirjoitin Javadoc dokumentaatiota sovelluslogiikkaluokille, mutta tulevan refaktoroinnin vuoksi kaikkia toisteista koodia sisältäviä metodeja en turhaan kommentoinut. Päivitin myös hieman määrittelydokumenttia ohjaajalta saatujen laajennusehdotusten perusteella.

Alustavaa käyttöliittymää tehdessäni opin uusia JavaFX:n ominaisuuksia. Käyttöliittymäkirjaston käyttöönotto aiheutti aluksi yhteensopivuusongelmia gradlen vanhemman version kanssa. Selviteltyäni asiaa sain ongelman ratkaistua gradle wrapperin avulla. Käyttöliittymän ja muun sovelluslogiikan suunnitteluun ja toteuttamiseen kului paljon enenmmän aikaa kuin varsinaisten järjestämisalgoritmien kirjoittamiseen. Aloitin lisäys- ja kuplajärjestämisestä, sillä halusin päästä mahdollisimman nopeasti kokeilemaan ja kehittämään sovelluksen perustoiminnallisuuksia, kuten eri vertailuasetusten valintaa.

Sovelluksen toiminnan ja järjestämisalgoritmien vertailun kannalta oleellista on, että vertailtavat algoritmit järjestävät sisällöltään ja järjestykseltään saman satunnaisesti luodun taulukon ja että useiden toistokertojen välissä taulukon alkuperäinen järjestys palautetaan. Ongelmaksi muodostui se, että tein alkuperäisestä järjestämättömästä taulukosta kopion .clone() -metodilla ja käytin tätä kopiota järjestämisalgoritmien saamana syötteenä. Mittaustulosten perusteella jokin vaikutti olevan pielessä ja tajusin, että kloonaaminen säilyttää alkuperäisen taulukon olioviitteen. Yritin kiertää ongelman luomalla aina alkuperäistä järjestämätöntä taulukkoa tarvittaessa uuden taulukko-olion ja kopioimalla siihen alkuperäisen taulukon sisällön System.arraycopy()-metodilla, jolloin uuteen taulukkoon tehtyjen muutosten ei pitäisi enää vaikuttaa alkuperäisen taulukon järjestykseen. En ole edelleenkään ihan varma, toimiiko sovellus tältä osin oikein, mutta pyrin selvittämään asiaa.

Seuraavaksi aion refaktoroida järjestämisalgoritmeista vastaavat luokat siten, että kiireessä toteutetut toisteista koodia sisältävät metodit siirtyvät yliluokan vastuulle. Järjestämisalgoritmeista pika- ja lomitusjärjestäminen on tarkoitus lisätä seuraavaksi sovellukseen. Käyttöliittymään ei ole toistaiseksi tulossa suuria muutoksia. Yritän myös keksiä millä tavoin ajan mittaamisesta ja taulukoiden satunnaisgeneroinnista vastuussa olevia metodeja olisi mielekästä yksikkötestata.


(2. viikon aikana työhön käytetty tuntimäärä: 13 h)